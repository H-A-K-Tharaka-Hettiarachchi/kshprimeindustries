<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 Not Found | KSHPRIME INDUSTRIES</title>
    <link rel="icon" href="icons/icon.png" type="image/png" sizes="32x32">
    <link rel="stylesheet" href="css/main.css">
    <style>
        .not-found {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .error-code {
            font-family: var(--font-mono);
            font-size: 8rem;
            font-weight: bold;
            color: var(--accent-color);
            line-height: 1;
            margin-bottom: 10px;
            position: relative;
            text-shadow: 0 0 10px rgba(255, 0, 122, 0.5);
        }

        .error-code::before {
            content: "404";
            position: absolute;
            top: 0;
            left: 0;
            color: var(--primary-color);
            opacity: 0.5;
            z-index: -1;
            transform: translate(-5px, -5px);
            text-shadow: 0 0 10px rgba(0, 255, 213, 0.5);
        }

        .error-code::after {
            content: "404";
            position: absolute;
            top: 0;
            left: 0;
            color: var(--secondary-color);
            opacity: 0.5;
            z-index: -1;
            transform: translate(5px, 5px);
            text-shadow: 0 0 10px rgba(0, 163, 255, 0.5);
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px);
            pointer-events: none;
            z-index: 10;
        }

        .search-form {
            max-width: 500px;
            margin: 30px auto;
        }

        .input-group {
            display: flex;
        }

        .input-group input {
            flex: 1;
            padding: 15px;
            background-color: rgba(10, 32, 48, 0.8);
            border: 1px solid rgba(0, 255, 213, 0.3);
            border-radius: 4px 0 0 4px;
            color: var(--text-color);
            font-family: var(--font-sans);
        }

        .input-group button {
            padding: 15px 25px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            color: var(--background-darker);
            border: none;
            border-radius: 0 4px 4px 0;
            font-weight: bold;
            cursor: pointer;
            font-family: var(--font-mono);
        }

        .navigation-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }

        .nav-option {
            padding: 10px 20px;
            background-color: rgba(10, 32, 48, 0.8);
            border: 1px solid rgba(0, 255, 213, 0.3);
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .nav-option:hover {
            transform: translateY(-3px);
            border-color: var(--primary-color);
            box-shadow: 0 5px 15px rgba(0, 255, 213, 0.2);
        }

        @keyframes flicker {

            0%,
            19.999%,
            22%,
            62.999%,
            64%,
            64.999%,
            70%,
            100% {
                opacity: 1;
            }

            20%,
            21.999%,
            63%,
            63.999%,
            65%,
            69.999% {
                opacity: 0.33;
            }
        }

        .flickering {
            animation: flicker 4s linear infinite;
        }

        /* Terminal control dots animation */
        .control {
            position: relative;
            animation: controlFloat 3s infinite ease-in-out;
        }

        .control.red {
            animation-delay: 0s;
        }

        .control.yellow {
            animation-delay: 0.5s;
        }

        .control.green {
            animation-delay: 1s;
        }

        @keyframes controlFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }

        /* Glitch text effect */
        .glitch {
            position: relative;
            color: var(--text-color);
            font-size: 2rem;
            letter-spacing: 0.2em;
            animation: glitchText 5s infinite linear alternate-reverse;
        }

        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch::before {
            color: #ff00ad;
            z-index: -1;
            clip: rect(44px, 450px, 56px, 0);
            transform: skew(0.5deg);
            animation: glitch-anim 5s infinite linear alternate-reverse;
            text-shadow: 0 0 5px #ff00ad;
        }

        .glitch::after {
            color: #00ffd5;
            z-index: -2;
            clip: rect(44px, 450px, 56px, 0);
            transform: skew(-0.5deg);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
            text-shadow: 0 0 5px #00ffd5;
        }

        @keyframes glitchText {

            0%,
            100% {
                text-shadow: 0 0 2px rgba(255, 255, 255, 0.8);
            }

            33% {
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.8),
                    3px 3px 5px rgba(0, 255, 255, 0.5),
                    -3px -3px 5px rgba(255, 0, 255, 0.5);
            }

            66% {
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.8),
                    -3px 3px 5px rgba(0, 255, 255, 0.5),
                    3px -3px 5px rgba(255, 0, 255, 0.5);
            }
        }

        @keyframes glitch-anim {
            0% {
                clip: rect(55px, 9999px, 91px, 0);
                transform: skew(0.52deg);
            }

            5% {
                clip: rect(83px, 9999px, 98px, 0);
                transform: skew(0.6deg);
            }

            10% {
                clip: rect(66px, 9999px, 82px, 0);
                transform: skew(0.29deg);
            }

            15% {
                clip: rect(13px, 9999px, 52px, 0);
                transform: skew(0.38deg);
            }

            20% {
                clip: rect(65px, 9999px, 91px, 0);
                transform: skew(0.45deg);
            }

            25% {
                clip: rect(7px, 9999px, 100px, 0);
                transform: skew(0.05deg);
            }

            30% {
                clip: rect(1px, 9999px, 31px, 0);
                transform: skew(0.31deg);
            }

            35% {
                clip: rect(5px, 9999px, 35px, 0);
                transform: skew(0.86deg);
            }

            40% {
                clip: rect(95px, 9999px, 59px, 0);
                transform: skew(0.4deg);
            }

            45% {
                clip: rect(55px, 9999px, 67px, 0);
                transform: skew(0.52deg);
            }

            50% {
                clip: rect(93px, 9999px, 32px, 0);
                transform: skew(0.96deg);
            }

            55% {
                clip: rect(91px, 9999px, 61px, 0);
                transform: skew(0.34deg);
            }

            60% {
                clip: rect(1px, 9999px, 49px, 0);
                transform: skew(0.02deg);
            }

            65% {
                clip: rect(9px, 9999px, 72px, 0);
                transform: skew(0.48deg);
            }

            70% {
                clip: rect(66px, 9999px, 13px, 0);
                transform: skew(0.95deg);
            }

            75% {
                clip: rect(76px, 9999px, 95px, 0);
                transform: skew(0.11deg);
            }

            80% {
                clip: rect(93px, 9999px, 62px, 0);
                transform: skew(0.66deg);
            }

            85% {
                clip: rect(93px, 9999px, 4px, 0);
                transform: skew(0.35deg);
            }

            90% {
                clip: rect(1px, 9999px, 2px, 0);
                transform: skew(0.94deg);
            }

            95% {
                clip: rect(11px, 9999px, 35px, 0);
                transform: skew(0.31deg);
            }

            100% {
                clip: rect(19px, 9999px, 25px, 0);
                transform: skew(0.89deg);
            }
        }

        @keyframes glitch-anim2 {
            0% {
                clip: rect(18px, 9999px, 95px, 0);
                transform: skew(0.44deg);
            }

            5% {
                clip: rect(95px, 9999px, 51px, 0);
                transform: skew(0.3deg);
            }

            10% {
                clip: rect(32px, 9999px, 45px, 0);
                transform: skew(0.67deg);
            }

            15% {
                clip: rect(40px, 9999px, 96px, 0);
                transform: skew(0.84deg);
            }

            20% {
                clip: rect(42px, 9999px, 51px, 0);
                transform: skew(0.98deg);
            }

            25% {
                clip: rect(25px, 9999px, 51px, 0);
                transform: skew(0.06deg);
            }

            30% {
                clip: rect(38px, 9999px, 67px, 0);
                transform: skew(0.85deg);
            }

            35% {
                clip: rect(82px, 9999px, 23px, 0);
                transform: skew(0.66deg);
            }

            40% {
                clip: rect(80px, 9999px, 32px, 0);
                transform: skew(0.89deg);
            }

            45% {
                clip: rect(23px, 9999px, 50px, 0);
                transform: skew(0.65deg);
            }

            50% {
                clip: rect(70px, 9999px, 41px, 0);
                transform: skew(0.67deg);
            }

            55% {
                clip: rect(51px, 9999px, 8px, 0);
                transform: skew(0.5deg);
            }

            60% {
                clip: rect(30px, 9999px, 64px, 0);
                transform: skew(0.29deg);
            }

            65% {
                clip: rect(100px, 9999px, 70px, 0);
                transform: skew(0.59deg);
            }

            70% {
                clip: rect(66px, 9999px, 76px, 0);
                transform: skew(0.35deg);
            }

            75% {
                clip: rect(100px, 9999px, 97px, 0);
                transform: skew(0.88deg);
            }

            80% {
                clip: rect(71px, 9999px, 92px, 0);
                transform: skew(0.42deg);
            }

            85% {
                clip: rect(59px, 9999px, 95px, 0);
                transform: skew(0.7deg);
            }

            90% {
                clip: rect(50px, 9999px, 37px, 0);
                transform: skew(0.1deg);
            }

            95% {
                clip: rect(79px, 9999px, 61px, 0);
                transform: skew(0.79deg);
            }

            100% {
                clip: rect(12px, 9999px, 28px, 0);
                transform: skew(0.73deg);
            }
        }

        /* Neural network background */
        .neural-network {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        /* Button hover effect */
        .input-group button {
            position: relative;
            overflow: hidden;
        }

        .input-group button::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .input-group button:hover::after {
            left: 100%;
        }

        /* Terminal blinking cursor */
        .command::after {
            content: '|';
            animation: blink 1s infinite step-end;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        /* Status line */
        .status-inactive {
            color: var(--accent-color);
            animation: statusBlink 2s infinite;
        }

        @keyframes statusBlink {

            0%,
            49% {
                opacity: 1;
            }

            50%,
            100% {
                opacity: 0.5;
            }
        }

        /* Nav option hover effect */
        .nav-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 213, 0.2), transparent);
            transform: translateX(-100%);
            transition: 0.5s;
            z-index: -1;
        }

        .nav-option:hover::before {
            transform: translateX(100%);
        }

        /* Data scanner effect */
        .scanner-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(0, 255, 213, 0.8),
                    transparent);
            z-index: 9;
            animation: scanDown 3s linear infinite;
            box-shadow: 0 0 10px rgba(0, 255, 213, 0.5);
            pointer-events: none;
        }

        @keyframes scanDown {
            0% {
                transform: translateY(-10px);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        /* Floating particles */
        .particle {
            position: fixed;
            border-radius: 50%;
            background-color: rgba(0, 255, 213, 0.5);
            pointer-events: none;
            z-index: -1;
        }

        .terminal-window {
            animation: terminal-glow 8s ease-in-out infinite;
        }

        @keyframes terminal-glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(0, 255, 213, 0.3), 0 0 20px rgba(0, 255, 213, 0.2);
            }

            50% {
                box-shadow: 0 0 30px rgba(0, 255, 213, 0.7), 0 0 60px rgba(0, 255, 213, 0.4);
            }
        }

        /* Digital Rain Effect (Matrix-style) */
        .digital-rain-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.07;
        }

        .rain-column {
            position: absolute;
            top: -100px;
            font-family: monospace;
            color: var(--primary-color);
            font-size: 14px;
            line-height: 1;
            text-shadow: 0 0 5px var(--primary-color);
            white-space: nowrap;
            animation-name: digitalRain;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        @keyframes digitalRain {
            0% {
                transform: translateY(-100%);
                opacity: 1;
            }

            80% {
                opacity: 0.5;
            }

            100% {
                transform: translateY(calc(100vh + 100px));
                opacity: 0;
            }
        }

        /* HUD Overlay Elements */
        .hud-corner {
            position: fixed;
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.7;
        }

        .hud-top-left {
            top: 20px;
            left: 20px;
            border-top: 2px solid var(--primary-color);
            border-left: 2px solid var(--primary-color);
        }

        .hud-top-right {
            top: 20px;
            right: 20px;
            border-top: 2px solid var(--primary-color);
            border-right: 2px solid var(--primary-color);
        }

        .hud-bottom-left {
            bottom: 20px;
            left: 20px;
            border-bottom: 2px solid var(--primary-color);
            border-left: 2px solid var(--primary-color);
        }

        .hud-bottom-right {
            bottom: 20px;
            right: 20px;
            border-bottom: 2px solid var(--primary-color);
            border-right: 2px solid var(--primary-color);
        }

        .hud-scanner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    rgba(0, 255, 213, 0.5) 50%,
                    transparent 100%);
            opacity: 0.6;
            pointer-events: none;
            z-index: 999;
            animation: scanScreen 4s linear infinite;
        }

        @keyframes scanScreen {
            0% {
                transform: translateY(-5px);
            }

            100% {
                transform: translateY(100vh);
            }
        }

        /* Circuit Board Pattern */
        .circuit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L90 10 L90 90 L10 90 Z' fill='none' stroke='rgba(0, 255, 213, 0.1)' stroke-width='0.5'/%3E%3Cpath d='M30 10 L30 30 L10 30' fill='none' stroke='rgba(0, 255, 213, 0.1)' stroke-width='0.5'/%3E%3Cpath d='M70 10 L70 30 L90 30' fill='none' stroke='rgba(0, 255, 213, 0.1)' stroke-width='0.5'/%3E%3Cpath d='M30 90 L30 70 L10 70' fill='none' stroke='rgba(0, 255, 213, 0.1)' stroke-width='0.5'/%3E%3Cpath d='M70 90 L70 70 L90 70' fill='none' stroke='rgba(0, 255, 213, 0.1)' stroke-width='0.5'/%3E%3C/svg%3E");
            opacity: 0.1;
            pointer-events: none;
            z-index: -1;
        }

        /* Animated Tech Background Grid */
        .tech-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: 50px 50px;
            background-image:
                linear-gradient(to right, rgba(0, 255, 213, 0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 255, 213, 0.05) 1px, transparent 1px);
            z-index: -2;
            opacity: 0.3;
            animation: gridPulse 4s infinite alternate;
        }

        @keyframes gridPulse {
            0% {
                opacity: 0.2;
                background-size: 50px 50px;
            }

            100% {
                opacity: 0.4;
                background-size: 51px 51px;
            }
        }

        /* Data Processing Animation - Fixed */
        .data-processing {
            position: fixed;
            right: 30px;
            bottom: 30px;
            font-family: monospace;
            font-size: 12px;
            color: var(--primary-color);
            pointer-events: none;
            text-align: right;
            opacity: 0.7;
            z-index: 1000;
            background-color: rgba(7, 21, 33, 0.7);
            padding: 10px;
            border-radius: 4px;
            border-left: 2px solid var(--primary-color);
            max-width: 300px;
        }

        .data-line {
            margin: 5px 0;
            white-space: nowrap;
            overflow: hidden;
            position: relative;
        }

        /* Scanner Effect */
        .scan-effect {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999;
            pointer-events: none;
            animation: scanEffect 10s linear infinite;
            opacity: 0;
            background: linear-gradient(to bottom,
                    rgba(0, 255, 213, 0) 0%,
                    rgba(0, 255, 213, 0.1) 50%,
                    rgba(0, 255, 213, 0) 100%);
        }

        @keyframes scanEffect {

            0%,
            100% {
                opacity: 0;
                transform: translateY(-100%);
            }

            10%,
            90% {
                opacity: 0.3;
            }

            50% {
                transform: translateY(100%);
            }
        }

        /* Loading Indicator */
        .loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }

        .loading-circle {
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spinLoading 1s linear infinite;
        }

        .loading-circle::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 2px solid transparent;
            border-top-color: var(--secondary-color);
            border-radius: 50%;
            animation: spinLoading 2s linear infinite reverse;
        }

        @keyframes spinLoading {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .data-processing {
                display: none;
            }

            .hud-corner {
                display: none;
            }

            .loading-indicator {
                display: none;
            }
        }
    </style>


</head>

<body class="body">
    <div class="noise-overlay"></div>
    <div class="scanlines"></div>
    

    <div class="not-found">
        <div class="container">
            <div class="terminal-window">
                <div class="terminal-header">
                    <div class="terminal-controls">
                        <span class="control red"></span>
                        <span class="control yellow"></span>
                        <span class="control green"></span>
                        <span class="terminal-title">system_error.sh</span>
                    </div>
                </div>
                <div class="terminal-content">
                    <div class="command-line">$ <span class="command">locate_resource</span></div>
                    <div class="response">// Error: Resource not found in system.</div>

                    <div class="error-code flickering">404</div>
                    <h1 class="glitch" data-text="ACCESS DENIED">ACCESS DENIED</h1>
                    <p>The digital entity you are seeking does not exist in this network node.</p>
                    <p>Signal lost. Connection terminated.</p>

                    <!-- Simple Cyber Scanner Component -->
                    <div style="margin: 30px 0;">
                        <div style="background-color: rgba(10, 32, 48, 0.7); border: 1px solid #00ffd5; border-radius: 4px; padding: 20px; font-family: monospace;">
                            <div id="simple-scan-text" style="color: #00ffd5; margin-bottom: 15px;">Scanning system directories...</div>
                            
                            <div style="height: 6px; background-color: rgba(0, 0, 0, 0.3); border-radius: 3px; overflow: hidden; margin-bottom: 15px;">
                                <div id="simple-progress-bar" style="height: 100%; background: linear-gradient(90deg, #00ffd5, #ff007a); width: 0%; transition: width 3s ease-in-out;"></div>
                            </div>
                            
                            <div style="color: #ff007a;">
                                <div>ERROR: Requested directory or file not found</div>
                            </div>
                        </div>
                    </div>

                    <div class="command-line">$ <span class="command">suggest_pathways</span></div>
                    <div class="navigation-options">
                        <a href="index.html" class="nav-option">Portal</a>
                        <a href="kshprime.html" class="nav-option">KSHPRIME</a>
                        <a href="personal.html" class="nav-option">Portfolio</a>
                    </div>

                    <div class="status-line">STATUS: <span class="status-inactive">DISCONNECTED</span></div>
                </div>
            </div>
        </div>
    </div>

    
    <div class="digital-rain-container" id="digitalRain"></div>
    <div class="circuit-overlay"></div>
    <div class="tech-grid"></div>

    
    <div class="hud-corner hud-top-left"></div>
    <div class="hud-corner hud-top-right"></div>
    <div class="hud-corner hud-bottom-left"></div>
    <div class="hud-corner hud-bottom-right"></div>
    <div class="hud-scanner"></div>

   
    <div class="scan-effect"></div>

   
    <div class="data-processing">
        <div class="data-line">Initializing kshprime_sys.exe...</div>
        <div class="data-line">Network status: online</div>
        <div class="data-line">Securing connection...</div>
        <div class="data-line">Encrypting data blocks...</div>
        <div class="data-line">Running system diagnostics...</div>
    </div>

   
    <div class="loading-indicator">
        <div class="loading-circle"></div>
    </div>

    <script>
        // Simulated terminal typing effect
        const responseLines = document.querySelectorAll('.response');

        responseLines.forEach((line, i) => {
            const text = line.textContent;
            line.textContent = '';

            setTimeout(() => {
                let charIndex = 0;
                const typeInterval = setInterval(() => {
                    if (charIndex < text.length) {
                        line.textContent += text.charAt(charIndex);
                        charIndex++;
                    } else {
                        clearInterval(typeInterval);
                    }
                }, 20);
            }, i * 500);
        });

        // Search form submission
        const searchForm = document.querySelector('.search-form');
        if (searchForm) {
            searchForm.addEventListener('submit', function (e) {
                e.preventDefault();
                const searchInput = this.querySelector('input').value.trim();

                if (searchInput) {
                    // Redirect to home page or search results
                    window.location.href = 'index.html';
                }
            });
        }

        // Random glitch effect
        setInterval(() => {
            const glitchElement = document.querySelector('.glitch');
            glitchElement.style.transform = `translate(${Math.random() * 4 - 2}px, ${Math.random() * 4 - 2}px)`;

            setTimeout(() => {
                glitchElement.style.transform = 'translate(0, 0)';
            }, 100);
        }, 3000);

        // Neural network background
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('neuralNetwork');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Resize on window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            // Neural network parameters
            const nodes = [];
            const numNodes = Math.min(80, Math.floor(window.innerWidth / 50));
            const connectionDistance = Math.min(200, window.innerWidth / 4);

            // Create nodes
            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 2 + 1,
                    vx: Math.random() * 0.5 - 0.25,
                    vy: Math.random() * 0.5 - 0.25,
                    pulseOpacity: 0,
                    pulseDirection: 1
                });
            }

            // Animation function
            function animate() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw connections and nodes
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];

                    // Update node position
                    node.x += node.vx;
                    node.y += node.vy;

                    // Boundary checking
                    if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                    if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

                    // Update pulse opacity
                    node.pulseOpacity += 0.01 * node.pulseDirection;
                    if (node.pulseOpacity >= 1 || node.pulseOpacity <= 0) {
                        node.pulseDirection *= -1;
                    }

                    // Draw connections
                    for (let j = i + 1; j < nodes.length; j++) {
                        const otherNode = nodes[j];
                        const dx = node.x - otherNode.x;
                        const dy = node.y - otherNode.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < connectionDistance) {
                            const opacity = (1 - distance / connectionDistance) * 0.4;
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(otherNode.x, otherNode.y);
                            ctx.strokeStyle = `rgba(0, 255, 213, ${opacity})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }

                    // Draw node
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 255, 213, ${0.3 + node.pulseOpacity * 0.3})`;
                    ctx.fill();
                }

                requestAnimationFrame(animate);
            }

            // Start animation
            animate();

            // Add floating particles
            const createParticles = () => {
                const particleCount = 15;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');

                    // Random properties
                    const size = Math.random() * 3 + 1;
                    const posX = Math.random() * window.innerWidth;
                    const posY = Math.random() * window.innerHeight;
                    const duration = Math.random() * 15 + 5;
                    const delay = Math.random() * 5;

                    // Set styles
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.left = `${posX}px`;
                    particle.style.top = `${posY}px`;
                    particle.style.opacity = `${Math.random() * 0.5 + 0.1}`;
                    particle.style.boxShadow = `0 0 ${size * 2}px rgba(0, 255, 213, 0.5)`;

                    // Animation
                    particle.style.animation = `
                        floatX ${duration}s infinite linear ${delay}s,
                        floatY ${duration * 0.8}s infinite ease-in-out ${delay}s,
                        pulse ${duration * 0.5}s infinite ease-in-out ${delay}s
                    `;

                    document.body.appendChild(particle);
                }
            };

            // Create particle animations
            const particleStyle = document.createElement('style');
            particleStyle.textContent = `
                @keyframes floatX {
                    0% { transform: translateX(0); }
                    25% { transform: translateX(100px); }
                    50% { transform: translateX(0); }
                    75% { transform: translateX(-100px); }
                    100% { transform: translateX(0); }
                }
                
                @keyframes floatY {
                    0%, 100% { transform: translateY(0); }
                    50% { transform: translateY(100px); }
                }
                
                @keyframes pulse {
                    0%, 100% { opacity: 0.1; }
                    50% { opacity: 0.5; }
                }
            `;
            document.head.appendChild(particleStyle);

            createParticles();

            // Add ripple effect to buttons and links
            const addRippleEffect = () => {
                const buttons = document.querySelectorAll('button, .nav-option');

                buttons.forEach(button => {
                    button.addEventListener('click', e => {
                        const x = e.clientX - button.getBoundingClientRect().left;
                        const y = e.clientY - button.getBoundingClientRect().top;

                        const ripple = document.createElement('span');
                        ripple.style.position = 'absolute';
                        ripple.style.width = '1px';
                        ripple.style.height = '1px';
                        ripple.style.borderRadius = '50%';
                        ripple.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                        ripple.style.transform = 'scale(0)';
                        ripple.style.left = `${x}px`;
                        ripple.style.top = `${y}px`;
                        ripple.style.animation = 'ripple 0.6s linear';

                        button.appendChild(ripple);

                        setTimeout(() => {
                            ripple.remove();
                        }, 600);
                    });
                });

                const rippleKeyframes = document.createElement('style');
                rippleKeyframes.textContent = `
                    @keyframes ripple {
                        to {
                            transform: scale(100);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(rippleKeyframes);
            };

            addRippleEffect();

            // Enhanced control dots animation
            const enhanceControlDots = () => {
                const controls = document.querySelectorAll('.control');

                controls.forEach(control => {
                    control.addEventListener('mouseenter', () => {
                        control.style.transform = 'scale(1.2)';
                        control.style.boxShadow = `0 0 10px ${getComputedStyle(control).backgroundColor}`;
                    });

                    control.addEventListener('mouseleave', () => {
                        control.style.transform = '';
                        control.style.boxShadow = '';
                    });
                });
            };

            enhanceControlDots();
        });

        // Cursor follow effect
        document.addEventListener('mousemove', e => {
            const cursor = document.createElement('div');
            cursor.style.position = 'fixed';
            cursor.style.width = '4px';
            cursor.style.height = '4px';
            cursor.style.borderRadius = '50%';
            cursor.style.backgroundColor = 'rgba(0, 255, 213, 0.7)';
            cursor.style.boxShadow = '0 0 5px rgba(0, 255, 213, 0.5)';
            cursor.style.pointerEvents = 'none';
            cursor.style.zIndex = '9999';
            cursor.style.left = `${e.clientX}px`;
            cursor.style.top = `${e.clientY}px`;
            cursor.style.transition = 'transform 0.1s, opacity 0.5s';

            document.body.appendChild(cursor);

            setTimeout(() => {
                cursor.style.transform = 'scale(2)';
                cursor.style.opacity = '0';
            }, 100);

            setTimeout(() => {
                cursor.remove();
            }, 600);
        });

        // Random glitch data packets
        setInterval(() => {
            if (Math.random() < 0.1) {
                const glitchPacket = document.createElement('div');
                glitchPacket.style.position = 'fixed';
                glitchPacket.style.width = `${Math.random() * 150 + 50}px`;
                glitchPacket.style.height = '1px';
                glitchPacket.style.backgroundColor = Math.random() > 0.5 ? 'rgba(0, 255, 213, 0.8)' : 'rgba(255, 0, 122, 0.8)';
                glitchPacket.style.boxShadow = `0 0 5px ${glitchPacket.style.backgroundColor}`;
                glitchPacket.style.left = `${Math.random() * window.innerWidth}px`;
                glitchPacket.style.top = `${Math.random() * window.innerHeight}px`;
                glitchPacket.style.zIndex = '5';
                glitchPacket.style.transform = `rotate(${Math.random() * 360}deg)`;
                glitchPacket.style.pointerEvents = 'none';

                document.body.appendChild(glitchPacket);

                setTimeout(() => {
                    glitchPacket.remove();
                }, 300);
            }
        }, 1000);

        // Error code glitch effect
        const errorCode = document.querySelector('.error-code');
        setInterval(() => {
            if (Math.random() < 0.3) {
                errorCode.style.transform = `translate(${Math.random() * 8 - 4}px, ${Math.random() * 8 - 4}px)`;
                setTimeout(() => {
                    errorCode.style.transform = '';
                }, 150);
            }
        }, 2000);

        // Enhance input field with cyber effect
        const searchInput = document.querySelector('input');
        if (searchInput) {
            searchInput.addEventListener('focus', function () {
                this.style.boxShadow = '0 0 15px rgba(0, 255, 213, 0.4), inset 0 0 10px rgba(0, 255, 213, 0.2)';
                this.style.borderColor = 'var(--primary-color)';

                // Add typing simulation
                if (!this.dataset.hasTypingEffect) {
                    this.dataset.hasTypingEffect = 'true';
                    const placeholder = this.placeholder;
                    this.placeholder = '';

                    let i = 0;
                    const typeInterval = setInterval(() => {
                        if (i < placeholder.length) {
                            this.placeholder += placeholder.charAt(i);
                            i++;
                        } else {
                            clearInterval(typeInterval);
                        }
                    }, 50);
                }
            });

            searchInput.addEventListener('blur', function () {
                this.style.boxShadow = '';
                this.style.borderColor = 'rgba(0, 255, 213, 0.3)';
            });
        }

        // Add floating text fragments
        const addTextFragments = () => {
            const binaryDigits = ['0', '1'];
            const fragments = ['404', 'ERROR', 'SYSTEM', 'FAILED', 'ACCESS', 'DENIED'];

            setInterval(() => {
                if (Math.random() < 0.03) {
                    const fragment = document.createElement('div');
                    fragment.style.position = 'fixed';
                    fragment.style.color = 'rgba(0, 255, 213, 0.15)';
                    fragment.style.fontFamily = 'monospace';
                    fragment.style.fontSize = `${Math.random() * 14 + 8}px`;
                    fragment.style.userSelect = 'none';
                    fragment.style.pointerEvents = 'none';
                    fragment.style.zIndex = '0';
                    fragment.style.left = `${Math.random() * window.innerWidth}px`;
                    fragment.style.top = `${Math.random() * window.innerHeight}px`;

                    // Choose between binary or text fragment
                    if (Math.random() < 0.7) {
                        // Binary string
                        let binaryString = '';
                        for (let i = 0; i < 8; i++) {
                            binaryString += binaryDigits[Math.floor(Math.random() * 2)];
                        }
                        fragment.textContent = binaryString;
                    } else {
                        // Text fragment
                        fragment.textContent = fragments[Math.floor(Math.random() * fragments.length)];
                        fragment.style.opacity = '0.2';
                    }

                    document.body.appendChild(fragment);

                    // Animate and remove
                    fragment.animate([
                        { opacity: 0, transform: 'translateY(0)' },
                        { opacity: 0.5, transform: 'translateY(-20px)' },
                        { opacity: 0, transform: 'translateY(-40px)' }
                    ], {
                        duration: 3000,
                        easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)'
                    });

                    setTimeout(() => {
                        fragment.remove();
                    }, 3000);
                }
            }, 500);
        };

        addTextFragments();
        
        // Enhanced hover effects for navigation options
        const navOptions = document.querySelectorAll('.nav-option');
        navOptions.forEach(option => {
            option.addEventListener('mouseenter', function () {
                // Create glow effect
                this.style.boxShadow = '0 0 15px rgba(0, 255, 213, 0.4)';
                this.style.color = '#ffffff';
                this.style.borderColor = 'var(--primary-color)';

                // Add highlight animation
                const highlight = document.createElement('div');
                highlight.style.position = 'absolute';
                highlight.style.top = '0';
                highlight.style.left = '0';
                highlight.style.width = '100%';
                highlight.style.height = '100%';
                highlight.style.background = 'radial-gradient(circle at center, rgba(0, 255, 213, 0.3) 0%, transparent 70%)';
                highlight.style.opacity = '0';
                highlight.style.transition = 'opacity 0.3s ease';
                highlight.style.pointerEvents = 'none';

                this.style.position = 'relative';
                this.appendChild(highlight);

                setTimeout(() => {
                    highlight.style.opacity = '1';
                }, 10);
            });

            option.addEventListener('mouseleave', function () {
                this.style.boxShadow = '';
                this.style.color = '';
                this.style.borderColor = 'rgba(0, 255, 213, 0.3)';

                const highlight = this.querySelector('div');
                if (highlight) {
                    highlight.style.opacity = '0';
                    setTimeout(() => {
                        highlight.remove();
                    }, 300);
                }
            });

            // Add dynamic data attribute for hover text
            option.setAttribute('data-hover', option.textContent);
        });

        // Dynamic scanner line effect
        const scannerLine = document.querySelector('.scanner-line');
        document.addEventListener('mousemove', e => {
            // Occasionally make scanner line follow cursor height
            if (Math.random() < 0.05) {
                scannerLine.style.animation = 'none';
                scannerLine.style.top = `${e.clientY}px`;
                scannerLine.style.opacity = '0.8';

                setTimeout(() => {
                    scannerLine.style.opacity = '0';
                    setTimeout(() => {
                        scannerLine.style.animation = 'scanDown 3s linear infinite';
                        scannerLine.style.opacity = '';
                    }, 500);
                }, 300);
            }
        });

        // Add hacker-style typing animation to heading
        const animateHackerTitle = () => {
            const heading = document.querySelector('h1');
            const originalText = heading.textContent;
            const originalDataText = heading.getAttribute('data-text');

            setInterval(() => {
                if (Math.random() < 0.3) {
                    let scrambledText = '';
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()_+-=[]{}|;:,./<>?';

                    // Scramble a few characters
                    for (let i = 0; i < originalText.length; i++) {
                        if (Math.random() < 0.3) {
                            scrambledText += chars[Math.floor(Math.random() * chars.length)];
                        } else {
                            scrambledText += originalText[i];
                        }
                    }

                    heading.textContent = scrambledText;
                    heading.setAttribute('data-text', scrambledText);

                    // Restore after a short delay
                    setTimeout(() => {
                        heading.textContent = originalText;
                        heading.setAttribute('data-text', originalDataText);
                    }, 200);
                }
            }, 2000);
        };

        animateHackerTitle();

        // Enhance terminal controls (dots)
        const controls = document.querySelectorAll('.control');
        controls.forEach(control => {
            // Add pulse effect
            control.style.animation = `${control.classList.contains('red') ? 'redPulse' :
                control.classList.contains('yellow') ? 'yellowPulse' :
                    'greenPulse'} 3s infinite alternate ease-in-out, 
                                       controlFloat 3s infinite ${Math.random() * 2}s ease-in-out`;
        });

        // Add pulse animations for controls
        const controlAnimations = document.createElement('style');
        controlAnimations.textContent = `
            @keyframes redPulse {
                0%, 100% { box-shadow: 0 0 5px rgba(255, 59, 48, 0.5); }
                50% { box-shadow: 0 0 10px rgba(255, 59, 48, 0.8); }
            }
            
            @keyframes yellowPulse {
                0%, 100% { box-shadow: 0 0 5px rgba(255, 204, 0, 0.5); }
                50% { box-shadow: 0 0 10px rgba(255, 204, 0, 0.8); }
            }
            
            @keyframes greenPulse {
                0%, 100% { box-shadow: 0 0 5px rgba(52, 199, 89, 0.5); }
                50% { box-shadow: 0 0 10px rgba(52, 199, 89, 0.8); }
            }
        `;
        document.head.appendChild(controlAnimations);

        // Create digital rain effect
        (function createDigitalRain() {
            const digitalRain = document.getElementById('digitalRain');
            if (!digitalRain) return;

            // Clear existing content
            digitalRain.innerHTML = '';

            const binaryChars = '10';
            const columns = Math.floor(window.innerWidth / 20);

            // Create initial columns
            for (let i = 0; i < columns; i++) {
                createRainColumn();
            }

            function createRainColumn() {
                const column = document.createElement('div');
                column.className = 'rain-column';
                column.style.left = `${Math.random() * window.innerWidth}px`;
                column.style.animationDuration = `${Math.random() * 10 + 10}s`;

                let columnContent = '';
                const columnLength = Math.floor(Math.random() * 20 + 10);

                for (let j = 0; j < columnLength; j++) {
                    columnContent += binaryChars.charAt(Math.floor(Math.random() * binaryChars.length)) + '<br>';
                }

                column.innerHTML = columnContent;
                digitalRain.appendChild(column);

                // When animation ends, remove the column and create a new one
                column.addEventListener('animationend', () => {
                    column.remove();
                    createRainColumn();
                });
            }
        })();

        // Data Processing Animation Fix
        (function createTypingAnimation() {
            const dataProcessing = document.querySelector('.data-processing');
            if (!dataProcessing) return;

            // Get all data lines
            const dataLines = document.querySelectorAll('.data-line');

            // Remove existing animation
            dataLines.forEach(line => {
                line.style.animation = 'none';
                line.style.width = 'auto';
                line.style.overflow = 'hidden';
                line.style.whiteSpace = 'nowrap';
                line.style.marginBottom = '5px';
                line.dataset.originalText = line.textContent;
                line.textContent = '';
            });

            // Create animated typing effect with continuous loop
            function startAnimations() {
                dataLines.forEach((line, index) => {
                    const originalText = line.dataset.originalText;
                    setTimeout(() => {
                        animateLine(line, originalText, index);
                    }, index * 800);
                });
            }

            function animateLine(line, text, index) {
                let charIndex = 0;
                line.textContent = '';

                const typeInterval = setInterval(() => {
                    if (charIndex < text.length) {
                        line.textContent += text.charAt(charIndex);
                        charIndex++;
                    } else {
                        clearInterval(typeInterval);

                        // After full text is shown, wait and reset for loop
                        setTimeout(() => {
                            // Clear and restart this line
                            line.textContent = '';
                            animateLine(line, text, index);
                        }, 3000 + (index * 500)); // Different delay for each line to avoid simultaneous resets
                    }
                }, 50 + Math.random() * 30); // Slightly random typing speed
            }

            // Start the animations
            startAnimations();
        })();

        // Network animation
        document.addEventListener('DOMContentLoaded', function () {
            const portalContainer = document.querySelector('.body');
            if (!portalContainer) return;

            // Only create this canvas if it doesn't conflict with neuralNetwork
            if (!document.getElementById('neuralNetwork')) {
                const canvas = document.createElement('canvas');
                Object.assign(canvas.style, {
                    position: 'absolute',
                    top: '0',
                    left: '0',
                    width: '100%',
                    height: '100%',
                    zIndex: '0',
                    opacity: '0.4',
                    borderRadius: '12px'
                });
                canvas.className = 'network-canvas';
                portalContainer.style.position = 'relative';
                portalContainer.insertBefore(canvas, portalContainer.firstChild);

                const ctx = canvas.getContext('2d');

                function resizeCanvas() {
                    canvas.width = portalContainer.offsetWidth;
                    canvas.height = portalContainer.offsetHeight;
                }

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                const color = '#1e90ff';

                class Node {
                    constructor() {
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.vx = (Math.random() - 0.5) * 1.2;
                        this.vy = (Math.random() - 0.5) * 1.2;
                        this.radius = Math.random() * 1.2 + 0.8;
                    }

                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                    }

                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                }

                const nodes = [];
                const density = 10000; // Lower = more nodes
                const nodeCount = Math.floor(canvas.width * canvas.height / density);

                for (let i = 0; i < nodeCount; i++) {
                    nodes.push(new Node());
                }

                function animate() {
                    requestAnimationFrame(animate);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    nodes.forEach(node => {
                        node.update();
                        node.draw();
                    });

                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const dx = nodes[i].x - nodes[j].x;
                            const dy = nodes[i].y - nodes[j].y;
                            const distanceSq = dx * dx + dy * dy;
                            const maxDistSq = 90 * 90;

                            if (distanceSq < maxDistSq) {
                                const opacity = 1 - distanceSq / maxDistSq;
                                ctx.beginPath();
                                ctx.moveTo(nodes[i].x, nodes[i].y);
                                ctx.lineTo(nodes[j].x, nodes[j].y);
                                ctx.strokeStyle = `rgba(30,144,255,${opacity * 0.5})`;
                                ctx.lineWidth = 0.6;
                                ctx.stroke();
                            }
                        }
                    }
                }

                animate();
            }
        });
        
        // Scanner component animation
        (function() {
            // Get elements by ID
            var scanText = document.getElementById('simple-scan-text');
            var progressBar = document.getElementById('simple-progress-bar');
            
            // Messages array
            var messages = [
                'Scanning system directories...',
                'Searching cache memory...',
                'Checking network paths...',
                'Analyzing request parameters...',
                'Validating URL structure...',
                'Querying database records...'
            ];
            
            var index = 0;
            
            // Function to update text
            function updateText() {
                if (scanText) {
                    scanText.innerText = messages[index];
                    index = (index + 1) % messages.length;
                }
            }
            
            // Start the animation
            if (progressBar) {
                progressBar.style.width = '100%';
            }
            
            // Set interval for text rotation
            setInterval(updateText, 2000);
        })();
    </script>
    <!-- Add this right after your <body class="body"> line -->
<script>
    // Make sure neural network animation works
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            const canvas = document.getElementById('neuralNetwork');
            if (canvas && canvas.getContext) {
                const ctx = canvas.getContext('2d');
                
                // Reset canvas dimensions
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Animation variables
                const nodes = [];
                const numNodes = Math.min(80, Math.floor(window.innerWidth / 50));
                const connectionDistance = Math.min(200, window.innerWidth / 4);
                
                // Create nodes
                for (let i = 0; i < numNodes; i++) {
                    nodes.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 1,
                        vx: Math.random() * 0.5 - 0.25,
                        vy: Math.random() * 0.5 - 0.25,
                        pulseOpacity: 0,
                        pulseDirection: 1
                    });
                }
                
                // Animation function
                function animate() {
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw connections and nodes
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        
                        // Update node position
                        node.x += node.vx;
                        node.y += node.vy;
                        
                        // Boundary checking
                        if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                        if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
                        
                        // Update pulse opacity
                        node.pulseOpacity += 0.01 * node.pulseDirection;
                        if (node.pulseOpacity >= 1 || node.pulseOpacity <= 0) {
                            node.pulseDirection *= -1;
                        }
                        
                        // Draw connections
                        for (let j = i + 1; j < nodes.length; j++) {
                            const otherNode = nodes[j];
                            const dx = node.x - otherNode.x;
                            const dy = node.y - otherNode.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < connectionDistance) {
                                const opacity = (1 - distance / connectionDistance) * 0.4;
                                ctx.beginPath();
                                ctx.moveTo(node.x, node.y);
                                ctx.lineTo(otherNode.x, otherNode.y);
                                ctx.strokeStyle = `rgba(0, 255, 213, ${opacity})`;
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }
                        }
                        
                        // Draw node
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(0, 255, 213, ${0.3 + node.pulseOpacity * 0.3})`;
                        ctx.fill();
                    }
                    
                    requestAnimationFrame(animate);
                }
                
                // Start animation
                animate();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
            }
        }, 500); // Small delay to ensure DOM is ready
    });
    </script>
</body>

</html>